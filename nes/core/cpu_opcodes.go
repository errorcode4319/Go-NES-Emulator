package core 

//MOS6502 OPCodes

//Return Additional Cycle

// Add with Carry  
func OP_ADC(cpu *CPU) uint8 {

    return 0
}

// And (with Accumulator)
func OP_AND(cpu *CPU) uint8 {

    return 0
}

// Arithmetic Shift Left
func OP_ASL(cpu *CPU) uint8 {

    return 0
}

// Branch on Carry Clear 
func OP_BCC(cpu *CPU) uint8 {

    return 0
}

// Branch on Carry Set 
func OP_BCS(cpu *CPU) uint8 {

    return 0 
}

// Branch on Equal (zero set)
func OP_BEQ(cpu *CPU) uint8 {

    return 0 
}

// Bit Test
func OP_BIT(cpu *CPU) uint8 {

    return 0
}

// Branch on Minus
func OP_BMI(cpu *CPU) uint8 {

    return 0
}

// Branch on Not Equal 
func OP_BNE(cpu *CPU) uint8 {

    return 0 
}

// Branch on Plus (negative clear) 
func OP_BPL(cpu *CPU) uint8 {

    return 0
}

// Break / Interrupt
func OP_BRK(cpu *CPU) uint8 {

    return 0
}

// Branch on Overflow Clear 
func OP_BVC(cpu *CPU) uint8 {

    return 0 
}

// Branch on Ovwerflow Set 
func OP_BVS(cpu *CPU) uint8 {

    return 0 
}

// Clear Carry 
func OP_CLC(cpu *CPU) uint8 {

    return 0 
}

// Clear Decimal
func OP_CLD(cpu *CPU) uint8 {
    
    return 0 
}

// Clear Interrupt Disable 
func OP_CLI(cpu *CPU) uint8 {

    return 0 
}

// Clear Overflow 
func OP_CLV(cpu *CPU) uint8 {

    return 0 
}

// Compare (with accumulator)
func OP_CMP(cpu *CPU) uint8 {

    return 0 
}

// Compare with X 
func OP_CPX(cpu *CPU) uint8 {

    return 0 
}

// Compare with Y
func OP_CPY(cpu *CPU) uint8 {

    return 0 
}

// Decrement
func OP_DEC(cpu *CPU) uint8 {

    return 0 
}

// Decrement X 
func OP_DEX(cpu *CPU) uint8 {

    return 0 
}

// Decrement Y 
func OP_DEY(cpu *CPU) uint8 {
    
    return 0 
}

// Exclusive or (with accumulator)
func OP_EOR(cpu *CPU) uint8 {

    return 0 
}

// Increment
func OP_INC(cpu *CPU) uint8 {

    return 0 
}

// Increment X 
func OP_INX(cpu *CPU) uint8 {

    return 0 
}

// Increment Y
func OP_INY(cpu *CPU) uint8 {

    return 0
}

// Jump
func OP_JMP(cpu *CPU) uint8 {

    return 0 
}

// Jump Subroutine
func OP_JSR(cpu *CPU) uint8 {

    return 0 
}

// Load Accumulator 
func OP_LDA(cpu *CPU) uint8 {

    return 0
}

// Load X 
func OP_LDX(cpu *CPU) uint8 {
    
    return 0 
}

// Load Y 
func OP_LDY(cpu *CPU) uint8 {

    return 0 
}

// Logical Shift Right
func OP_LSR(cpu *CPU) uint8 {

    return 0
}

// No Operation
func OP_NOP(cpu *CPU) uint8 {

    return 0 
}

// Or (with accumulator) 
func OP_ORA(cpu *CPU) uint8 {

    return 0
}

// Push Accumulator
func OP_PHA(cpu *CPU) uint8 {

    return 0
}

// Push Processor Status (SR) 
func OP_PHP(cpu *CPU) uint8 {

    return 0
}

// Pull accumulator 
func OP_PLA(cpu *CPU) uint8 {

    return 0
}

// Pull Processor Status (SR)
func OP_PLP(cpu *CPU) uint8 {

    return 0 
}

// Rotate Left 
func OP_ROL(cpu *CPU) uint8 {

    return 0
}

// Rotate Right 
func OP_ROR(cpu *CPU) uint8 {

    return 0
}

// Return from Interrupt
func OP_RTI(cpu *CPU) uint8 {

    return 0
}

// Return from Subroutine 
func OP_RTS(cpu *CPU) uint8 {

    return 0
}

// Subtract with Carry
func OP_SBC(cpu *CPU) uint8 {

    return 0
}

// Set Carry 
func OP_SEC(cpu *CPU) uint8 {

    return 0
}

// Set Decimal
func OP_SED(cpu *CPU) uint8 {

    return 0
}

// Set Interrupt Disable
func OP_SEI(cpu *CPU) uint8 {

    return 0
}

// Store Accumulator
func OP_STA(cpu *CPU) uint8 {

    return 0
}

// Store X
func OP_STX(cpu *CPU) uint8 {

    return 0
}

// Store Y
func OP_STY(cpu *CPU) uint8 {

    return 0
}

// Transfer Accumulator to X
func OP_TAX(cpu *CPU) uint8 {

    return 0
}

// Transfer Accumulator to Y
func OP_TAY(cpu *CPU) uint8 {

    return 0
}

// Transfer stack pointer to X
func OP_TSX(cpu *CPU) uint8 {
    
    return 0
}

// Transfer X to accumulator
func OP_TXA(cpu *CPU) uint8 {

    return 0
}

// Transfer X to stack pointer 
func OP_TXS(cpu *CPU) uint8 {

    return 0
}

// Transfer Y to accumulator
func OP_TYA(cpu *CPU) uint8 {

    return 0
}
